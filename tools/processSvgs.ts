import { promises as fs } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { optimize } from "svgo";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const repoRoot = path.resolve(__dirname);

const TITLE = "SVG Gallery";

async function listFilesRecursive(
	dir: string,
	ignore = new Set([".git", "node_modules"]),
) {
	const out: string[] = [];
	async function walk(curr: string) {
		for (const ent of await fs.readdir(curr, { withFileTypes: true })) {
			if (ent.isDirectory()) {
				if (!ignore.has(ent.name)) await walk(path.join(curr, ent.name));
			} else {
				out.push(path.join(curr, ent.name));
			}
		}
	}
	await walk(dir);
	return out;
}

function escapePath(p: string) {
	return encodeURI(p);
}

function svgImgs(svgs: string[]) {
	const shown = svgs.slice(0, 999);
	const thumbs = shown
		.map((svgPath) => {
			const rel = path
				.relative(path.join(repoRoot, ".."), svgPath)
				.replace(/\\/g, "/");
			return `<a href="${escapePath(rel)}" title="${rel}"><img src="${escapePath(rel)}" alt="${rel}" width="160" /></a>`;
		})
		.join("\n"); // NO leading spaces on each line!

	return `
<details open>
<summary> (${svgs.length})</summary>

<div style="display:flex;flex-wrap:wrap;gap:12px;align-items:flex-start;">
${thumbs}
</div>

</details>`;
}

const writeSvgFile = async (svgs: string[]) => {
	const svgInfo = svgs.map(async (svgPath) => {
		const fileContent = await fs.readFile(svgPath, "utf8");
		const name = path.basename(svgPath, ".svg");

		return {
			name,
			content: optimize(fileContent, {
				multipass: true,
				plugins: ["convertStyleToAttrs", "preset-default"],
			}).data,
		};
	});

	const allSvgInfo = await Promise.all(svgInfo);

	const outFile = path.join(repoRoot, "..", "svgs.ts");
	const fileContent = `// This file is auto-generated by tools/processSvgs.ts. Do not edit by hand.
export const svgList = ${JSON.stringify(allSvgInfo, null, 4)};
`;

	await fs.writeFile(outFile, fileContent, "utf8");
	console.log(`Wrote ${allSvgInfo.length} SVG contents to ${outFile}`);

	const svgsWithoutDataColor = allSvgInfo.filter(
		(svg) => !/data-color=/.test(svg.content),
	);
	if (svgsWithoutDataColor.length > 0) {
		console.warn(
			`Warning: ${svgsWithoutDataColor.length} SVGs are missing data-color="":`,
		);
		svgsWithoutDataColor.forEach((svg) => console.warn(` - ${svg.name}`));
	}
};

export const processSVGs = async () => {
	const all = await listFilesRecursive(path.join(repoRoot, "..", "svgs"));
	const svgs = all.filter((f) => f.toLowerCase().endsWith(".svg")).sort();
	console.log(`Found ${svgs.length} SVG files.`, svgs);

	const rawMd = `# ${TITLE}

Total SVGs: **${svgs.length}**
Last updated: ${new Date().toISOString().split("T")[0]}

> Generated by \`tools/processSvgs.ts\`. Do not edit by hand.

${svgImgs(svgs)}
`;

	const md = rawMd.replace(/^\s{4,}(<\/?a\b.*|<\/?img\b.*)>/gm, "$1");

	await fs.writeFile(path.join(repoRoot, "..", "README.md"), md, "utf8");
	console.log("README.md generated with inline SVG previews âœ…");

	await writeSvgFile(svgs);
};

if (import.meta.url === `file://${process.argv[1]}`) {
	processSVGs();
}
